[{"title":"ç‰›å®¢ç½‘ - è¿·å®«é—®é¢˜ï¼ˆCè¯­è¨€ï¼‰","url":"/2024/04/22/ç‰›å®¢ç½‘è¿·å®«é—®é¢˜Cè¯­è¨€/","content":"\n\n\n@[TOC](æ–‡ç« ç›®å½•)\n\n---\n# å‰è¨€\n\nåŸé¢˜ï¼š\n[https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&ru=/exam/oj](https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&ru=/exam/oj)\n\n---\n\n# ä¸€ã€é¢˜ç›®è¦æ±‚\n## 1.è¾“å…¥\nè¾“å…¥ä¸¤ä¸ªæ•´æ•°ï¼ŒNä¸Mï¼Œåˆ†åˆ«ä»£è¡¨äºŒç»´æ•°ç»„çš„è¡Œæ•°ä¸åˆ—æ•°ã€‚å†è¾“å…¥å¯¹åº”çš„å€¼ï¼Œ1ä»£è¡¨å¢™å£ï¼Œ0ä»£è¡¨å¯èµ°çš„è·¯ï¼Œè¿·å®«åªæœ‰å”¯ä¸€ä¸€æ¡é€šé“å¯èµ°ã€‚\n<font color=#f111f1>ï¼ˆ0ï¼Œ0ï¼‰ä¸ºå…¥å£</font>\n<font color=#f111f1>ï¼ˆN - 1ï¼Œ M - 1ï¼‰ä¸ºå‡ºå£</font>\næ•°æ®èŒƒå›´ï¼š2 <= N <= 10ï¼Œ2 <= M<= 10\næ•°ç»„ä¸­ä»…åŒ…å«0å’Œ1\n<font color=red size=3>ç¤ºä¾‹ï¼š</font>\n\n<center><img src='https://img.cdn1.vip/i/6988ce8b4413f_1770573451.png' width='20%'/></center>\n\n## 2.è¾“å‡º\nçºµå‘è¾“å‡ºä»å…¥å£åˆ°å‡ºå£çš„è·¯å¾„\n<font color=red size=3>ç¤ºä¾‹ï¼š</font>\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img.cdn1.vip/i/6988ce8b4a236_1770573451.png)\n\n\n\n# äºŒã€æ€è·¯ä¸ç®—æ³•\næœ¬é¢˜é‡‡ç”¨**æ·±åº¦ä¼˜å…ˆæœç´¢+æ ˆ**çš„æ€è·¯ï¼Œä»å…¥å£å¼€å§‹èµ°ï¼Œæ¯æ¬¡èµ°è¿‡çš„è·¯æ ‡è®°ä¸º2ï¼ˆå…¥æ ˆï¼‰ï¼Œè‹¥èµ°åˆ°æŸä¸€æ¡ä¸é€šçš„è·¯çº¿ï¼Œåˆ™è¿”å›åˆ°è¯¥è·¯çº¿çš„èµ·ç‚¹å¤„ï¼ˆæŠŠä¸é€šçš„è·¯çº¿å‡ºæ ˆï¼‰ï¼Œå†èµ°æ²¡èµ°è¿‡çš„è·¯ï¼Œç›´åˆ°æ‰¾åˆ°å‡ºå£ä¸ºæ­¢ã€‚\n==Cè¯­è¨€å®ç°æ ˆæ•™ç¨‹ç§»æ­¥ä¸‹æ–¹é“¾æ¥â¬‡ï¸â¬‡ï¸â¬‡ï¸ğŸ¥º==\n[http://t.csdnimg.cn/8cAkt](http://t.csdnimg.cn/8cAkt)\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img.cdn1.vip/i/6988ce9774d8a_1770573463.webp)\n\n\n\n# ä¸‰ã€ä»£ç å®ç°\n## 1.åˆ›å»ºè¿·å®«\n```c\ntypedef struct path {\n    int row;\n    int col;\n} path;\n\nint main(){\n    int i = 0;\n    int N = 0, M = 0;//ç”¨æ¥æ¥æ”¶è¿·å®«çš„è¡Œæ•°ï¼ˆNï¼‰ä¸åˆ—æ•°ï¼ˆMï¼‰\n\n    while (scanf(\"%d%d\", &N, &M) != EOF){//å¯èƒ½ä¼šåˆ›å»ºå¤šä¸ªè¿·å®«ï¼Œå› æ­¤ç”¨EOFæ¥åˆ¤æ–­å¾ªç¯æ˜¯å¦ç»ˆæ­¢\n        int** maze = (int**)malloc(sizeof(int*)*N);//åŠ¨æ€å¼€è¾Ÿè¡Œæ•°ï¼ŒNè¡Œ\n        for (i = 0; i < N; i++){\n            maze[i] = (int*)malloc(sizeof(int)*M);//ç»™æ¯ä¸€è¡Œéƒ½ä¸ºMä¸ªæ•°ï¼ŒMåˆ—\n        }\n        for (i = 0; i < N; i++){\n            int j = 0;\n            for (j = 0; j < M; j++){\n                scanf(\"%d\", &maze[i][j]);//å¸ƒç½®è¿·å®«\n            }\n        }\n        path cur = {0,0};//åˆ›å»ºä¸€ä¸ªç”¨æ¥å­˜æ”¾è¿·å®«åæ ‡çš„ç»“æ„ä½“ï¼Œèµ‹åˆå§‹å€¼ä¸ºè¿·å®«çš„å…¥å£\n        stack exitPath;//åˆ›å»ºç”¨æ¥å­˜æ”¾è¿·å®«å‡ºå£è·¯å¾„çš„æ ˆ\n        StackInit(&exitPath);//åˆå§‹åŒ–æ ˆ\n        FindMazeExit(maze, N, M, cur, &exitPath);//å¯»æ‰¾è¿·å®«çš„å‡ºå£è·¯å¾„\n        PrintMazeExitPath(exitPath);//æ‰“å°è¿·å®«çš„å‡ºå£è·¯å¾„\n    }\n}\n```\n## 2.å¯»æ‰¾è¿·å®«çš„å‡ºå£è·¯å¾„\n\n```c\n//åˆ¤æ–­å½“å‰è·¯å¾„çš„åæ ‡æ˜¯å¦å¯èµ°\nbool isPass(int** maze, int row, int col, path cur){\n    if (cur.row < row && cur.col < col\n    && cur.row >= 0 && cur.col >= 0 && maze[cur.row][cur.col] == 0){\n        return true;\n    }\n    return false;\n}\n\n//å¯»æ‰¾å‡ºè·¯\nbool FindMazeExit(int** maze, int N, int M, path cur, stack* exitPath){\n    StackPush(exitPath, cur);//å°†å½“å‰åˆ°è¾¾çš„è·¯å¾„åæ ‡å…¥æ ˆ\n    maze[cur.row][cur.col] = 2;//èµ°è¿‡çš„è·¯èµ‹å€¼ä¸º2\n\n    if (cur.row == N - 1 && cur.col == M - 1){//è‹¥å½“å‰åæ ‡ä¸ºå‡ºå£è¿”å›çœŸ\n        return true;\n    }\n    path next = cur;//å­˜æ”¾å½“å‰åæ ‡ï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªå¯é€šçš„åæ ‡\n\n    //å‘è¿·å®«çš„ä¸Šæ–¹å¯»æ‰¾\n    next.row--;\n    if (isPass(maze, N, M, next)){//è‹¥è¯¥åæ ‡å¯èµ°\n        if (FindMazeExit(maze, N, M, next, exitPath)){//åˆ™é€’å½’è¯¥åæ ‡\n            return true;\n        }\n    }\n\n    //å‘è¿·å®«çš„ä¸‹æ–¹å¯»æ‰¾\n    next = cur;\n    next.row++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    //å‘è¿·å®«çš„å·¦æ–¹å¯»æ‰¾\n    next = cur;\n    next.col++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    //å‘è¿·å®«çš„å³æ–¹å¯»æ‰¾\n    next = cur;\n    next.col--;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    StackPop(exitPath);//å¦‚æœå½“å‰è·¯å¾„çš„åæ ‡ä¸ºæ­»è·¯ï¼Œå°±å°†å½“å‰åæ ‡å‡ºæ ˆ\n    return false;//å¹¶ä¸”è¿”å›false\n}\n```\n## 3.è¾“å‡ºè¿·å®«çš„å‡ºå£è·¯å¾„\n\n```c\nvoid PrintMazeExitPath(stack p){\n    //å› ä¸ºä¿å­˜çš„è·¯å¾„æ˜¯é¢ å€’çš„ï¼Œæ‰€ä»¥è¦åè½¬ä¸€ä¸‹å†è¾“å‡º\n    stack reversePath;//åˆ›å»ºä¸€ä¸ªç”¨æ¥ä¿å­˜åè½¬åè·¯å¾„çš„æ ˆ\n    StackInit(&reversePath);//åˆå§‹åŒ–\n    while (!StackEmpty(&p)){//è‹¥æ ˆä¸ºç©ºï¼Œå¾ªç¯åœæ­¢\n        StackPush(&reversePath, StackTop(&p));//å–å‡ºæ ˆé¡¶æ•°æ®ï¼Œå¹¶å…¥åˆ°reversePath\n        StackPop(&p);//å°†æ ˆé¡¶å‡ºæ ˆ\n    }\n    //æ‰“å°åè½¬åçš„è·¯å¾„\n    while (!StackEmpty(&reversePath)){//è‹¥æ ˆä¸ºç©ºï¼Œå¾ªç¯åœæ­¢\n        path cur = StackTop(&reversePath);//å°†æ ˆé¡¶æ•°æ®å–å‡º\n        printf(\"(%d,%d)\\n\", cur.row, cur.col);//æ‰“å°åæ ‡\n        StackPop(&reversePath);//å‡ºæ ˆ\n    }\n}\n```\n\n---\n# å››ã€å®Œæ•´ä»£ç \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\ntypedef struct path {\n    int row;\n    int col;\n} path;\n\ntypedef path StackDataType;\n\ntypedef struct Stack {\n\tStackDataType* vals;\n\tint top;\n\tint capacity;\n}stack;\n\nvoid StackInit(stack* p) {\n\tassert(p);\n\n\tp->vals = (StackDataType*)malloc(sizeof(StackDataType) * 4);\n\tp->capacity = 4;\n\tp->top = 0;\n}\n\nvoid StackDestroy(stack* p) {\n\tassert(p);\n\tfree(p->vals);\n\tp->vals = NULL;\n\tp->capacity = p->top = 0;\n}\n\nvoid StackPush(stack* p, StackDataType x) {\n\tassert(p);\n\n\tif (p->top == p->capacity) {\n\t\tStackDataType* tmp = (StackDataType*)realloc(p->vals, sizeof(StackDataType) * (p->capacity * 2));\n\t\tif (tmp) {\n\t\t\tp->capacity *= 2;\n\t\t\tp->vals = tmp;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"realloc fail!\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\tp->vals[p->top] = x;\n\tp->top++;\n}\n\nvoid StackPop(stack* p) {\n\tassert(p);\n\n\tif (p->top > 0) {\n\t\tp->top--;\n\t}\n\telse {\n\t\tprintf(\"stack no data\\n\");\n\t\texit(-1);\n\t}\n}\n\nStackDataType StackTop(stack* p) {\n\tassert(p);\n\n\tif (p->top == 0) {\n\t\tprintf(\"stack no data\\n\");\n\t\texit(-1);\n\t}\n\telse {\n\t\treturn p->vals[p->top - 1];\n\t}\n}\n\nint StackSize(stack* p) {\n\tassert(p);\n\n\treturn p->top;\n}\n\nbool StackEmpty(stack* p) {\n\tassert(p);\n\n\treturn p->top == 0;\n}\n\nvoid PrintMaze(int** maze, int row, int col){\n    int i = 0;\n    for (i = 0; i < row; i++){\n        int j = 0;\n        for (j = 0; j < col; j++){\n            printf(\"%d \", maze[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nbool isPass(int** maze, int row, int col, path cur){\n    if (cur.row < row && cur.col < col\n    && cur.row >= 0 && cur.col >= 0 && maze[cur.row][cur.col] == 0){\n        return true;\n    }\n    return false;\n}\n\nbool FindMazeExit(int** maze, int N, int M, path cur, stack* exitPath){\n    StackPush(exitPath, cur);\n    maze[cur.row][cur.col] = 2;\n\n    if (cur.row == N - 1 && cur.col == M - 1){\n        return true;\n    }\n    path next = cur;\n\n    next.row--;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    next = cur;\n    next.row++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    next = cur;\n    next.col++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    next = cur;\n    next.col--;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    StackPop(exitPath);\n    return false;\n}\n\nvoid PrintMazeExitPath(stack p){\n    stack reversePath;\n    StackInit(&reversePath);\n    while (!StackEmpty(&p)){\n        StackPush(&reversePath, StackTop(&p));\n        StackPop(&p);\n    }\n    while (!StackEmpty(&reversePath)){\n        path cur = StackTop(&reversePath);\n        printf(\"(%d,%d)\\n\", cur.row, cur.col);\n        StackPop(&reversePath);\n    }\n}\n\nint main(){\n    int i = 0;\n    int N = 0, M = 0;\n\n    while (scanf(\"%d%d\", &N, &M) != EOF){\n        int** maze = (int**)malloc(sizeof(int*)*N);\n        for (i = 0; i < N; i++){\n            maze[i] = (int*)malloc(sizeof(int)*M);\n        }\n        for (i = 0; i < N; i++){\n            int j = 0;\n            for (j = 0; j < M; j++){\n                scanf(\"%d\", &maze[i][j]);\n            }\n        }\n        path cur = {0,0};\n        stack exitPath;\n        StackInit(&exitPath);\n        FindMazeExit(maze, N, M, cur, &exitPath);\n        PrintMazeExitPath(exitPath);\n    }\n}\n```\n\n---\n\nä¸€å¼€å§‹å†™åœ¨csdnçš„ï¼Œç°åœ¨æ¬ä¸Šæ¥å‡‘ä¸ªæ•°\n\n[csdnæ–‡ç« é“¾æ¥](https://blog.csdn.net/ee268/article/details/137960370?fromshare=blogdetail&sharetype=blogdetail&sharerId=137960370&sharerefer=PC&sharesource=ee268&sharefrom=from_link)\n\n","tags":["cè¯­è¨€","æ•°æ®ç»“æ„","æ·±åº¦ä¼˜å…ˆæœç´¢"],"categories":["C"]}]