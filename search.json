[{"title":"vs2022é…ç½®protobuf","url":"/2025/09/08/vs2022é…ç½®protobuf/","content":"\n\n\n@[TOC](æ–‡ç« ç›®å½•)\n\n---\n\n# ä¸€ã€ç¼–è¯‘protobuf\n## ä¸‹è½½protobuf 21.9\n[https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases)\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/1.png)\n\n---\n\n## cmakeç¼–è¯‘protobuf\nè§£å‹å¥½ä¸‹è½½çš„å‹ç¼©åŒ…ï¼Œåœ¨`protobuf-3.21.9`æ–‡ä»¶å¤¹å†…åˆ›å»º`visualstudio`æ–‡ä»¶å¤¹\n\næ‰“å¼€cmakegui\n\nsource codeé€‰æ‹©protobufçš„`cmake`æ–‡ä»¶å¤¹\n\nbuild the binariesé€‰æ‹©åˆšåˆšåˆ›å»ºçš„`visualstudio`æ–‡ä»¶å¤¹\n\nå•å‡»å·¦ä¸‹è§’çš„`configure`\n\nç¬¬ä¸€ä¸ªä¸‹æ‹‰æ¡†é€‰æ‹©`visual studio 17 2022`ï¼Œå…¶ä»–é»˜è®¤ï¼Œç‚¹å‡»finish\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/2.png)\n\n---\n\nå‹¾é€‰æƒ³è¦çš„é…ç½®é€‰é¡¹åç‚¹å‡»`generate`\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/3.png)\n\n---\n\n## æ‰“å¼€vs2022\nç‚¹å‡»`visualstudio`æ–‡ä»¶å¤¹å†…çš„`protobuf.sln`è¿›å…¥vs\né€‰æ‹©å¥½é…ç½®ï¼Œdebugæˆ–releaseéƒ½è¡Œ\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/4.png)\n\n---\n\nå³å‡»`ALL_BUILD`é€‰æ‹©é‡æ–°ç”Ÿæˆï¼ˆæˆ‘è¿™é‡Œç”Ÿæˆçš„ä¸ºdebugç‰ˆæœ¬ï¼‰\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/5.png)\n\nè¿›å…¥åˆ°`visualstudio`æ–‡ä»¶å¤¹çš„`Debug`æ–‡ä»¶å¤¹å†…\n\nç„¶ååœ¨`protobuf`æ–‡ä»¶å¤¹å†…åˆ›å»ºä¸€ä¸ª`vs_test`æ–‡ä»¶å¤¹  (å–åéšæ„)ï¼Œé‡Œé¢å†åˆ›å»ºä¸€ä¸ª`bin`å’Œ`include`æ–‡ä»¶å¤¹\n\nç„¶åå¤åˆ¶`Debug`æ–‡ä»¶å¤¹å†…çš„æ‰€æœ‰æ–‡ä»¶åˆ°`bin`é‡Œé¢\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/6.png)\n\nå¤åˆ¶`protobuf`æ–‡ä»¶å¤¹ä¸‹`src`é‡Œçš„`google`æ–‡ä»¶å¤¹åˆ°`include`æ–‡ä»¶å¤¹å†…\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/7.png)\n\n# äºŒã€é…ç½®vs\n`å³å‡»é¡¹ç›®é€‰æ‹©å±æ€§`\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/8.png)\n\nåœ¨VC++ä¸­æ·»åŠ åŒ…å«ç›®å½•ï¼Œä¸º`vs_test`çš„`include`æ–‡ä»¶å¤¹\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/9.png)\n\nå†æ·»åŠ åº“ç›®å½•ï¼Œä¸º`vs_test`ä¸‹çš„`bin`æ–‡ä»¶å¤¹\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/10.png)\n\nå¹¶åœ¨`é“¾æ¥å™¨`çš„`è¾“å…¥`é€‰é¡¹ä¸­æ·»åŠ `é™„åŠ ä¾èµ–é¡¹`\n==libprotobufd.lib\nlibprotocd.lib==\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/11.png)\n\n`C/C++`çš„é¢„`å¤„ç†å™¨`é€‰é¡¹ä¸­æ·»åŠ `é¢„å¤„ç†å™¨å®šä¹‰`==PROTOBUF_USE_DLLS==\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/12.png)\n\n\n`ç‚¹å‡»ç¡®å®šå¹¶åº”ç”¨`\n\n# ä¸‰ã€æ·»åŠ ç¯å¢ƒå˜é‡\n\næ–°å»ºç³»ç»Ÿå˜é‡`PROTOBUF_HOME`\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/13.png)\n\nç³»ç»Ÿå˜é‡Pathä¸­æ·»åŠ `%PROTOBUF_HOME%`\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/14.png)\n# å››ã€æµ‹è¯•\n\nåœ¨é¡¹ç›®ç›®å½•ä¸­åˆ›å»º`test.proto`æ–‡ä»¶ï¼Œå¹¶å†™å…¥ä»¥ä¸‹å†…å®¹\n(æ–°å»ºæ–‡æœ¬æ–‡ä»¶å¹¶ä¿®æ”¹åç¼€å³å¯)\n```cpp\nsyntax = \"proto3\";\n\nmessage Test\n{\n\tstring name = 1;\n}\n```\n`å³å‡»é¡¹ç›®æ‰€åœ¨æ–‡ä»¶å¤¹ç©ºç™½å¤„é€‰æ‹©åœ¨ç»ˆç«¯ä¸­æ‰“å¼€`\n\nå¹¶è¾“å…¥ï¼Œ==protoc --cpp_out=. ./test.proto==\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/15.png)\n\næ·»åŠ ç”Ÿæˆçš„.ccå’Œ.hæ–‡ä»¶åˆ°é¡¹ç›®ä¸­\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/16.png)\n\né€‰æ‹©æ·»åŠ ç°æœ‰é¡¹ï¼Œæ·»åŠ ä¸Šè¿°ä¸¤ä¸ªæ–‡ä»¶\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/17.png)\n\næµ‹è¯•ä»£ç \n\n```cpp\n#include <iostream>\n#include \"test.pb.h\"\n\nint main()\n{\n    Test test;\n    test.set_name(\"Hello World\");\n    std::string str;\n\n    //åºåˆ—åŒ–åˆ°å­—ç¬¦ä¸²str\n    test.SerializeToString(&str);\n    std::cout << \"åºåˆ—åŒ–åˆ°å­—ç¬¦ä¸²ï¼š\" << str << std::endl;\n\n    //ä»å­—ç¬¦ä¸²ä¸­è§£æ\n    Test test2;\n    test2.ParseFromString(str);\n    std::cout << \"ä»å­—ç¬¦ä¸²è§£æï¼š\" << test.name() << std::endl;\n\n    return 0;\n}\n```\n\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](/images/blog-content-img/vs2022-Configure-Protobuf/18.png)\n\n---\n\n> csdnä¸Šçš„æŠ•ç¨¿ä¹Ÿæ˜¯æˆ‘çš„\n>\n> {% link \"https://blog.csdn.net/ee268/article/details/150590030?fromshare=blogdetail&sharetype=blogdetail&sharerId=150590030&sharerefer=PC&sharesource=ee268&sharefrom=from_link\" \"vs2022é…ç½®protobuf\" \"auto\" %}","tags":["c++","VistualStudio"],"categories":["Cpp"]},{"title":"Cè¯­è¨€å®ç° - æ ˆ","url":"/2024/04/22/æ ˆå®ç°Cè¯­è¨€/","content":"\n@[TOC](æ–‡ç« ç›®å½•)\n\n---\n\n# å‰è¨€\n## æ ˆçš„ä»‹ç»\næ ˆæ˜¯ä¸€ç§ç‰¹æ®Šçš„çº¿æ€§è¡¨ï¼Œæ•°æ®çš„å­˜å–æ–¹å¼æ˜¯<font color=red >åè¿›å…ˆå‡º</font>ï¼Œæœ€åè¿›å…¥çš„æ•°æ®ç§°ä¸ºæ ˆé¡¶ï¼Œç¬¬ä¸€ä¸ªè¿›å…¥çš„æ•°æ®ç§°ä¸ºæ ˆåº•ã€‚åªèƒ½åœ¨æ ˆé¡¶å¯¹æ•°æ®è¿›è¡Œè¯»å–ã€åˆ é™¤ã€æ’å…¥ã€‚\n==åˆ é™¤æ•°æ®ç§°ä½œï¼šå‡ºæ ˆæˆ–é€€æ ˆ==\n==æ’å…¥æ•°æ®ç§°ä½œï¼šè¿›æ ˆã€å…¥æ ˆæˆ–å‹æ ˆ==\n![å‡ºæ ˆåŠ¨å›¾æ¼”ç¤º](https://img.cdn1.vip/i/6989621ef275d_1770611230.webp)\n\n![å…¥æ ˆåŠ¨å›¾æ¼”ç¤º](https://img.cdn1.vip/i/698962248ce66_1770611236.webp)\n---\n\n# ä¸€ã€éœ€è¦å®ç°çš„æ¥å£\n\n```c\n//åˆå§‹åŒ–æ ˆ\nvoid StackInit(stack* p);\n//é”€æ¯æ ˆ\nvoid StackDestroy(stack* p);\n//å…¥æ ˆ\nvoid StackPush(stack* p, StackDataType x);\n//å‡ºæ ˆ\nvoid StackPop(stack* p);\n//å–å‡ºæ ˆé¡¶æ•°æ®\nStackDataType StackTop(stack* p);\n//è®¡ç®—æ ˆçš„å¤§å°\nint StackSize(stack* p);\n//æ ˆçš„åˆ¤ç©º\nbool StackEmpty(stack* p);\n```\n\n# äºŒã€ä»£ç å®ç°\n## 1.åˆ›å»ºæ ˆ\n`æ ˆå¯ä»¥ä½¿ç”¨æ•°ç»„æˆ–é“¾è¡¨å®ç°ï¼Œè¿™é‡Œä½¿ç”¨çš„æ˜¯æ•°ç»„`\n\n```c\ntypedef int StackDataType;//æ ˆä¸­å­˜å‚¨çš„æ•°æ®ä¸ºæ•´å‹\n//å°†å…¶é‡å‘½åçš„æ„ä¹‰æ˜¯æ–¹ä¾¿ä»¥åæ›´æ”¹æ•°æ®ç±»å‹\n\ntypedef struct Stack {\n\tStackDataType* vals;\n\tint top;//æ ˆé¡¶çš„ä¸‹æ ‡\n\tint capacity;//è®°å½•æ•°ç»„çš„å®¹é‡ï¼Œåˆ°è¾¾ä¸Šé™æ—¶æ‰©å®¹\n}stack;\n```\n\n## 2.å„æ¥å£åˆ›å»º\n### 1- åˆå§‹åŒ–æ ˆ\n\n```c\nvoid StackInit(stack* p) {\n\tassert(p);//ä½¿ç”¨æ–­è¨€é˜²æ­¢pä¸ºç©ºæŒ‡é’ˆï¼Œå¯ä»¥æ›´å¥½çš„æ‰¾åˆ°é”™è¯¯\n\n\tp->vals = (StackDataType*)malloc(sizeof(StackDataType) * 4);\n\tp->capacity = 4;\n\t//è®¾ç½®æ•°ç»„çš„åˆå§‹å¤§å°ä¸º4\n\tp->top = 0;//æ­¤æ—¶æ ˆé¡¶ä¸º0ï¼Œæ— ä»»ä½•æ•°æ®\n}\n```\n### 2 - é”€æ¯æ ˆ\n\n```c\nvoid StackDestroy(stack* p) {\n\tassert(p);//ä½¿ç”¨æ–­è¨€é˜²æ­¢pä¸ºç©ºæŒ‡é’ˆï¼Œå¯ä»¥æ›´å¥½çš„æ‰¾åˆ°é”™è¯¯\n\t\n\tfree(p->vals);//é‡Šæ”¾æ ˆä¸­çš„æ‰€æœ‰å€¼\n\tp->vals = NULL;//ç½®æˆç©ºæŒ‡é’ˆé˜²æ­¢é‡æŒ‡é’ˆçš„å‡ºç°\n\tp->capacity = p->top = 0;\n}\n```\n### 3 - å…¥æ ˆ\n\n```c\nvoid StackPush(stack* p, StackDataType x) {\n\tassert(p);//ä½¿ç”¨æ–­è¨€é˜²æ­¢pä¸ºç©ºæŒ‡é’ˆï¼Œå¯ä»¥æ›´å¥½çš„æ‰¾åˆ°é”™è¯¯\n\n\tif (p->top == p->capacity) {//æ ˆé¡¶å¦‚æœç­‰äºå®¹é‡å°±ä»£è¡¨æ ˆå·²ç»æ»¡äº†ï¼Œéœ€è¦æ‰©å®¹\n\t\tStackDataType* tmp = (StackDataType*)realloc(p->vals, sizeof(StackDataType) * (p->capacity * 2));\n\t\t//è¿™é‡Œæ‰©å®¹ä¸ºåŸå®¹é‡çš„äºŒå€\n\t\tif (tmp) {\n\t\t\tp->capacity *= 2;\n\t\t\tp->vals = tmp;\n\t\t}\n\t\telse {//è‹¥æœ‰æ‰©å®¹å¤±è´¥çš„æƒ…å†µå°±å¼ºåˆ¶ç»ˆæ­¢ç¨‹åº\n\t\t\tprintf(\"realloc fail!\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\tp->vals[p->top] = x;//å°†xæ’å…¥æ ˆé¡¶\n\tp->top++;//æ ˆé¡¶ä¸ºp->top - 1\n}\n```\n### 4 - å‡ºæ ˆ\n\n```c\nvoid StackPop(stack* p) {\n\tassert(p);//ä½¿ç”¨æ–­è¨€é˜²æ­¢pä¸ºç©ºæŒ‡é’ˆï¼Œå¯ä»¥æ›´å¥½çš„æ‰¾åˆ°é”™è¯¯\n\n\tif (p->top > 0) {//è¦ä¿è¯æ ˆä¸­è‡³å°‘å­˜åœ¨ä¸€ä¸ªæ•°æ®æ‰èƒ½å‡ºæ ˆ\n\t\tp->top--;\n\t}\n\telse {//æ— æ•°æ®å°±å¼ºåˆ¶ç»ˆæ­¢ç¨‹åº\n\t\tprintf(\"stack no data\\n\");\n\t\texit(-1);\n\t}\n}\n```\n\n### 5 -  å–å‡ºæ ˆé¡¶æ•°æ®\n\n```c\nStackDataType StackTop(stack* p) {\n\tassert(p);//ä½¿ç”¨æ–­è¨€é˜²æ­¢pä¸ºç©ºæŒ‡é’ˆï¼Œå¯ä»¥æ›´å¥½çš„æ‰¾åˆ°é”™è¯¯\n\n\tif (p->top == 0) {//æ ˆä¸­æ— æ•°æ®ï¼Œå¼ºåˆ¶ç»ˆæ­¢ç¨‹åº\n\t\tprintf(\"stack no data\\n\");\n\t\texit(-1);\n\t}\n\telse {\n\t\treturn p->vals[p->top - 1];//è¿”å›æ ˆé¡¶æ•°æ®\n\t\t//è¿™é‡Œå› ä¸ºåˆå§‹åŒ–æ ˆæ—¶p->topèµ‹çš„åˆå§‹å€¼ä¸º0ï¼Œå…¥æ ˆæ—¶å°†p->top++ï¼Œæ‰€ä»¥æ ˆé¡¶æ•°æ®æ˜¯å½“å‰p->topæ‰€æŒ‡å‘çš„åä¸€ä½\n\t}\n}\n```\n### 6 - è®¡ç®—æ ˆçš„å¤§å°\n\n```c\nint StackSize(stack* p) {\n\tassert(p);//ä½¿ç”¨æ–­è¨€é˜²æ­¢pä¸ºç©ºæŒ‡é’ˆï¼Œå¯ä»¥æ›´å¥½çš„æ‰¾åˆ°é”™è¯¯\n\n\treturn p->top;//åˆå§‹ä»0å¼€å§‹ï¼Œæ ˆé¡¶æ˜¯p->topçš„åä¸€ä½ï¼Œæ‰€ä»¥å½“å‰p->topçš„å€¼å°±æ˜¯æ ˆçš„æ•°æ®ä¸ªæ•°\n}\n```\n### 7 - æ ˆçš„åˆ¤ç©º\n\n```c\nbool StackEmpty(stack* p) {\n\tassert(p);//ä½¿ç”¨æ–­è¨€é˜²æ­¢pä¸ºç©ºæŒ‡é’ˆï¼Œå¯ä»¥æ›´å¥½çš„æ‰¾åˆ°é”™è¯¯\n\n\treturn p->top == 0;//è‹¥æ ˆé¡¶ä¸º0åˆ™ä»£è¡¨æ ˆä¸­æ— æ•°æ®ï¼Œè¿”å›true\n\t//æ ˆé¡¶ä¸ä¸º0ä»£è¡¨æ ˆä¸ä¸ºç©ºï¼Œè¿”å›false\n}\n```\n# ä¸‰ã€æµ‹è¯•\n\n```c\nvoid stacktest1() {\n\tstack p;//ä¸éœ€è¦èµ‹å€¼ï¼Œä½¿ç”¨StackInit\n\tStackInit(&p);//ä¼ å‚éœ€è¦ä¼ åœ°å€\n    \n    //ä¾æ¬¡å…¥æ•°æ® \n\tStackPush(&p, 1);\n\tStackPush(&p, 2);\n\tStackPush(&p, 3);\n\tStackPush(&p, 4);\n\n    //ä¸€å…±å…¥äº†å››ä¸ªæ•°æ®\n    printf(\"StackSize = %d\\n\", StackSize(&p));\n\n\twhile (!StackEmpty(&p)) {\n\t//ä½¿ç”¨é€»è¾‘éè¿ç®—ç¬¦ï¼ˆé0ä¸ºå‡ï¼Œ0ä¸ºçœŸï¼‰ï¼Œæ ˆä¸ä¸ºç©ºæ—¶ç»§ç»­ï¼Œä¸ºç©ºæ—¶åœæ­¢\n\t//å› ä¸ºæ ˆä¸ºç©ºè¿”å›trueï¼Œä¸ä¸ºç©ºè¿”å›false\n\t\tprintf(\"%d\\n\", StackTop(&p));//å–å‡ºæ ˆé¡¶æ•°æ®å¹¶è¾“å‡º\n\t\tStackPop(&p);//è¾“å‡ºå®Œä¹‹åå°†æ ˆé¡¶ç§»é™¤\n\t}\n\t\n\tStackDestroy(&p);//æ ˆä½¿ç”¨å®Œæ¯•éœ€è¦é”€æ¯ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼\n}\n\nint main() {\n\tstacktest1();\n\treturn 0;\n}\n```\n# äº”ã€è¿è¡Œç»“æœ\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img.cdn1.vip/i/6989621e87292_1770611230.png)\næ ˆçš„å¤§å°ä¸º4ï¼Œè¾“å‡ºçš„é¡ºåºæ»¡è¶³äº†åè¿›å…ˆå‡º\n\n==æ ˆçš„åº”ç”¨ï¼ˆè¿·å®«é—®é¢˜ï¼‰ï¼š==\n\n{% link \"https://ee268.github.io/2024/04/22/ç‰›å®¢ç½‘è¿·å®«é—®é¢˜Cè¯­è¨€/\" \"è¿·å®«é—®é¢˜cè¯­è¨€\" \"https://img.cdn1.vip/i/69895fa2b6b67_1770610594.png\" %}\n\n[http://t.csdnimg.cn/cdkD5](http://t.csdnimg.cn/cdkD5)\n\n---\n\n# æ€»ç»“\nç¬¬ä¸€æ¬¡å†™åšå®¢ï¼Œä¸è¶³ä¹‹å¤„è¿˜è¯·å¤§å®¶æŒ‡å‡ºğŸ¥ºã€‚\n\n---\n\nä»¥å‰è‡ªå·±åœ¨csdnå†™çš„ï¼Œæ–°æ­çš„åšå®¢æ²¡æœ‰å¤šå°‘æ–‡ç« ï¼Œæ¬ä¸Šæ¥å‡‘æ•°\n\n{% link \"https://blog.csdn.net/ee268/article/details/137997577?fromshare=blogdetail&sharetype=blogdetail&sharerId=137997577&sharerefer=PC&sharesource=ee268&sharefrom=from_link\" \"Cè¯­è¨€å®ç° - æ ˆ\" %}\n","tags":["cè¯­è¨€","æ•°æ®ç»“æ„"],"categories":["C"]},{"title":"ç‰›å®¢ç½‘ - è¿·å®«é—®é¢˜ï¼ˆCè¯­è¨€ï¼‰","url":"/2024/04/22/ç‰›å®¢ç½‘è¿·å®«é—®é¢˜Cè¯­è¨€/","content":"\n\n\n@[TOC](æ–‡ç« ç›®å½•)\n\n---\n# å‰è¨€\n\nåŸé¢˜ï¼š\n[https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&ru=/exam/oj](https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&ru=/exam/oj)\n\n---\n\n# ä¸€ã€é¢˜ç›®è¦æ±‚\n## 1.è¾“å…¥\nè¾“å…¥ä¸¤ä¸ªæ•´æ•°ï¼ŒNä¸Mï¼Œåˆ†åˆ«ä»£è¡¨äºŒç»´æ•°ç»„çš„è¡Œæ•°ä¸åˆ—æ•°ã€‚å†è¾“å…¥å¯¹åº”çš„å€¼ï¼Œ1ä»£è¡¨å¢™å£ï¼Œ0ä»£è¡¨å¯èµ°çš„è·¯ï¼Œè¿·å®«åªæœ‰å”¯ä¸€ä¸€æ¡é€šé“å¯èµ°ã€‚\n<font color=#f111f1>ï¼ˆ0ï¼Œ0ï¼‰ä¸ºå…¥å£</font>\n<font color=#f111f1>ï¼ˆN - 1ï¼Œ M - 1ï¼‰ä¸ºå‡ºå£</font>\næ•°æ®èŒƒå›´ï¼š2 <= N <= 10ï¼Œ2 <= M<= 10\næ•°ç»„ä¸­ä»…åŒ…å«0å’Œ1\n<font color=red size=3>ç¤ºä¾‹ï¼š</font>\n\n<center><img src='https://img.cdn1.vip/i/6988ce8b4413f_1770573451.png' width='20%'/></center>\n\n## 2.è¾“å‡º\nçºµå‘è¾“å‡ºä»å…¥å£åˆ°å‡ºå£çš„è·¯å¾„\n<font color=red size=3>ç¤ºä¾‹ï¼š</font>\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img.cdn1.vip/i/6988ce8b4a236_1770573451.png)\n\n\n\n# äºŒã€æ€è·¯ä¸ç®—æ³•\næœ¬é¢˜é‡‡ç”¨**æ·±åº¦ä¼˜å…ˆæœç´¢+æ ˆ**çš„æ€è·¯ï¼Œä»å…¥å£å¼€å§‹èµ°ï¼Œæ¯æ¬¡èµ°è¿‡çš„è·¯æ ‡è®°ä¸º2ï¼ˆå…¥æ ˆï¼‰ï¼Œè‹¥èµ°åˆ°æŸä¸€æ¡ä¸é€šçš„è·¯çº¿ï¼Œåˆ™è¿”å›åˆ°è¯¥è·¯çº¿çš„èµ·ç‚¹å¤„ï¼ˆæŠŠä¸é€šçš„è·¯çº¿å‡ºæ ˆï¼‰ï¼Œå†èµ°æ²¡èµ°è¿‡çš„è·¯ï¼Œç›´åˆ°æ‰¾åˆ°å‡ºå£ä¸ºæ­¢ã€‚\n==Cè¯­è¨€å®ç°æ ˆæ•™ç¨‹ç§»æ­¥ä¸‹æ–¹é“¾æ¥â¬‡ï¸â¬‡ï¸â¬‡ï¸ğŸ¥º==\n[http://t.csdnimg.cn/8cAkt](http://t.csdnimg.cn/8cAkt)\n![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img.cdn1.vip/i/6988ce9774d8a_1770573463.webp)\n\n\n\n# ä¸‰ã€ä»£ç å®ç°\n## 1.åˆ›å»ºè¿·å®«\n```c\ntypedef struct path {\n    int row;\n    int col;\n} path;\n\nint main(){\n    int i = 0;\n    int N = 0, M = 0;//ç”¨æ¥æ¥æ”¶è¿·å®«çš„è¡Œæ•°ï¼ˆNï¼‰ä¸åˆ—æ•°ï¼ˆMï¼‰\n\n    while (scanf(\"%d%d\", &N, &M) != EOF){//å¯èƒ½ä¼šåˆ›å»ºå¤šä¸ªè¿·å®«ï¼Œå› æ­¤ç”¨EOFæ¥åˆ¤æ–­å¾ªç¯æ˜¯å¦ç»ˆæ­¢\n        int** maze = (int**)malloc(sizeof(int*)*N);//åŠ¨æ€å¼€è¾Ÿè¡Œæ•°ï¼ŒNè¡Œ\n        for (i = 0; i < N; i++){\n            maze[i] = (int*)malloc(sizeof(int)*M);//ç»™æ¯ä¸€è¡Œéƒ½ä¸ºMä¸ªæ•°ï¼ŒMåˆ—\n        }\n        for (i = 0; i < N; i++){\n            int j = 0;\n            for (j = 0; j < M; j++){\n                scanf(\"%d\", &maze[i][j]);//å¸ƒç½®è¿·å®«\n            }\n        }\n        path cur = {0,0};//åˆ›å»ºä¸€ä¸ªç”¨æ¥å­˜æ”¾è¿·å®«åæ ‡çš„ç»“æ„ä½“ï¼Œèµ‹åˆå§‹å€¼ä¸ºè¿·å®«çš„å…¥å£\n        stack exitPath;//åˆ›å»ºç”¨æ¥å­˜æ”¾è¿·å®«å‡ºå£è·¯å¾„çš„æ ˆ\n        StackInit(&exitPath);//åˆå§‹åŒ–æ ˆ\n        FindMazeExit(maze, N, M, cur, &exitPath);//å¯»æ‰¾è¿·å®«çš„å‡ºå£è·¯å¾„\n        PrintMazeExitPath(exitPath);//æ‰“å°è¿·å®«çš„å‡ºå£è·¯å¾„\n    }\n}\n```\n## 2.å¯»æ‰¾è¿·å®«çš„å‡ºå£è·¯å¾„\n\n```c\n//åˆ¤æ–­å½“å‰è·¯å¾„çš„åæ ‡æ˜¯å¦å¯èµ°\nbool isPass(int** maze, int row, int col, path cur){\n    if (cur.row < row && cur.col < col\n    && cur.row >= 0 && cur.col >= 0 && maze[cur.row][cur.col] == 0){\n        return true;\n    }\n    return false;\n}\n\n//å¯»æ‰¾å‡ºè·¯\nbool FindMazeExit(int** maze, int N, int M, path cur, stack* exitPath){\n    StackPush(exitPath, cur);//å°†å½“å‰åˆ°è¾¾çš„è·¯å¾„åæ ‡å…¥æ ˆ\n    maze[cur.row][cur.col] = 2;//èµ°è¿‡çš„è·¯èµ‹å€¼ä¸º2\n\n    if (cur.row == N - 1 && cur.col == M - 1){//è‹¥å½“å‰åæ ‡ä¸ºå‡ºå£è¿”å›çœŸ\n        return true;\n    }\n    path next = cur;//å­˜æ”¾å½“å‰åæ ‡ï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªå¯é€šçš„åæ ‡\n\n    //å‘è¿·å®«çš„ä¸Šæ–¹å¯»æ‰¾\n    next.row--;\n    if (isPass(maze, N, M, next)){//è‹¥è¯¥åæ ‡å¯èµ°\n        if (FindMazeExit(maze, N, M, next, exitPath)){//åˆ™é€’å½’è¯¥åæ ‡\n            return true;\n        }\n    }\n\n    //å‘è¿·å®«çš„ä¸‹æ–¹å¯»æ‰¾\n    next = cur;\n    next.row++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    //å‘è¿·å®«çš„å·¦æ–¹å¯»æ‰¾\n    next = cur;\n    next.col++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    //å‘è¿·å®«çš„å³æ–¹å¯»æ‰¾\n    next = cur;\n    next.col--;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    StackPop(exitPath);//å¦‚æœå½“å‰è·¯å¾„çš„åæ ‡ä¸ºæ­»è·¯ï¼Œå°±å°†å½“å‰åæ ‡å‡ºæ ˆ\n    return false;//å¹¶ä¸”è¿”å›false\n}\n```\n## 3.è¾“å‡ºè¿·å®«çš„å‡ºå£è·¯å¾„\n\n```c\nvoid PrintMazeExitPath(stack p){\n    //å› ä¸ºä¿å­˜çš„è·¯å¾„æ˜¯é¢ å€’çš„ï¼Œæ‰€ä»¥è¦åè½¬ä¸€ä¸‹å†è¾“å‡º\n    stack reversePath;//åˆ›å»ºä¸€ä¸ªç”¨æ¥ä¿å­˜åè½¬åè·¯å¾„çš„æ ˆ\n    StackInit(&reversePath);//åˆå§‹åŒ–\n    while (!StackEmpty(&p)){//è‹¥æ ˆä¸ºç©ºï¼Œå¾ªç¯åœæ­¢\n        StackPush(&reversePath, StackTop(&p));//å–å‡ºæ ˆé¡¶æ•°æ®ï¼Œå¹¶å…¥åˆ°reversePath\n        StackPop(&p);//å°†æ ˆé¡¶å‡ºæ ˆ\n    }\n    //æ‰“å°åè½¬åçš„è·¯å¾„\n    while (!StackEmpty(&reversePath)){//è‹¥æ ˆä¸ºç©ºï¼Œå¾ªç¯åœæ­¢\n        path cur = StackTop(&reversePath);//å°†æ ˆé¡¶æ•°æ®å–å‡º\n        printf(\"(%d,%d)\\n\", cur.row, cur.col);//æ‰“å°åæ ‡\n        StackPop(&reversePath);//å‡ºæ ˆ\n    }\n}\n```\n\n---\n# å››ã€å®Œæ•´ä»£ç \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\ntypedef struct path {\n    int row;\n    int col;\n} path;\n\ntypedef path StackDataType;\n\ntypedef struct Stack {\n\tStackDataType* vals;\n\tint top;\n\tint capacity;\n}stack;\n\nvoid StackInit(stack* p) {\n\tassert(p);\n\n\tp->vals = (StackDataType*)malloc(sizeof(StackDataType) * 4);\n\tp->capacity = 4;\n\tp->top = 0;\n}\n\nvoid StackDestroy(stack* p) {\n\tassert(p);\n\tfree(p->vals);\n\tp->vals = NULL;\n\tp->capacity = p->top = 0;\n}\n\nvoid StackPush(stack* p, StackDataType x) {\n\tassert(p);\n\n\tif (p->top == p->capacity) {\n\t\tStackDataType* tmp = (StackDataType*)realloc(p->vals, sizeof(StackDataType) * (p->capacity * 2));\n\t\tif (tmp) {\n\t\t\tp->capacity *= 2;\n\t\t\tp->vals = tmp;\n\t\t}\n\t\telse {\n\t\t\tprintf(\"realloc fail!\\n\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\tp->vals[p->top] = x;\n\tp->top++;\n}\n\nvoid StackPop(stack* p) {\n\tassert(p);\n\n\tif (p->top > 0) {\n\t\tp->top--;\n\t}\n\telse {\n\t\tprintf(\"stack no data\\n\");\n\t\texit(-1);\n\t}\n}\n\nStackDataType StackTop(stack* p) {\n\tassert(p);\n\n\tif (p->top == 0) {\n\t\tprintf(\"stack no data\\n\");\n\t\texit(-1);\n\t}\n\telse {\n\t\treturn p->vals[p->top - 1];\n\t}\n}\n\nint StackSize(stack* p) {\n\tassert(p);\n\n\treturn p->top;\n}\n\nbool StackEmpty(stack* p) {\n\tassert(p);\n\n\treturn p->top == 0;\n}\n\nvoid PrintMaze(int** maze, int row, int col){\n    int i = 0;\n    for (i = 0; i < row; i++){\n        int j = 0;\n        for (j = 0; j < col; j++){\n            printf(\"%d \", maze[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nbool isPass(int** maze, int row, int col, path cur){\n    if (cur.row < row && cur.col < col\n    && cur.row >= 0 && cur.col >= 0 && maze[cur.row][cur.col] == 0){\n        return true;\n    }\n    return false;\n}\n\nbool FindMazeExit(int** maze, int N, int M, path cur, stack* exitPath){\n    StackPush(exitPath, cur);\n    maze[cur.row][cur.col] = 2;\n\n    if (cur.row == N - 1 && cur.col == M - 1){\n        return true;\n    }\n    path next = cur;\n\n    next.row--;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    next = cur;\n    next.row++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    next = cur;\n    next.col++;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    next = cur;\n    next.col--;\n    if (isPass(maze, N, M, next)){\n        if (FindMazeExit(maze, N, M, next, exitPath)){\n            return true;\n        }\n    }\n\n    StackPop(exitPath);\n    return false;\n}\n\nvoid PrintMazeExitPath(stack p){\n    stack reversePath;\n    StackInit(&reversePath);\n    while (!StackEmpty(&p)){\n        StackPush(&reversePath, StackTop(&p));\n        StackPop(&p);\n    }\n    while (!StackEmpty(&reversePath)){\n        path cur = StackTop(&reversePath);\n        printf(\"(%d,%d)\\n\", cur.row, cur.col);\n        StackPop(&reversePath);\n    }\n}\n\nint main(){\n    int i = 0;\n    int N = 0, M = 0;\n\n    while (scanf(\"%d%d\", &N, &M) != EOF){\n        int** maze = (int**)malloc(sizeof(int*)*N);\n        for (i = 0; i < N; i++){\n            maze[i] = (int*)malloc(sizeof(int)*M);\n        }\n        for (i = 0; i < N; i++){\n            int j = 0;\n            for (j = 0; j < M; j++){\n                scanf(\"%d\", &maze[i][j]);\n            }\n        }\n        path cur = {0,0};\n        stack exitPath;\n        StackInit(&exitPath);\n        FindMazeExit(maze, N, M, cur, &exitPath);\n        PrintMazeExitPath(exitPath);\n    }\n}\n```\n\n---\n\nä¸€å¼€å§‹å†™åœ¨csdnçš„ï¼Œç°åœ¨æ¬ä¸Šæ¥å‡‘ä¸ªæ•°\n\n[csdnæ–‡ç« é“¾æ¥](https://blog.csdn.net/ee268/article/details/137960370?fromshare=blogdetail&sharetype=blogdetail&sharerId=137960370&sharerefer=PC&sharesource=ee268&sharefrom=from_link)\n\n","tags":["cè¯­è¨€","æ•°æ®ç»“æ„","æ·±åº¦ä¼˜å…ˆæœç´¢"],"categories":["C"]}]